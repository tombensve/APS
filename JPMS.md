As the JDK has run forward at a rather quick pace now (at least compared to before) and there are things to consider. I've been thinking a lot, and done some test shots. 

One big question is _Going with JPMS or stick to OSGi ?_. I have now come to the conslusion that JPMS really sucks in comparison to what OSGi provides. I have found information on the net that are critical to JPMS (<https://developer.jboss.org/blogs/scott.stark/2017/04/14/critical-deficiencies-in-jigsawjsr-376-java-platform-module-system-ec-member-concerns?\_sscc=t>) and I can agree with them in much. My personal reflection is that the old ServiceLoader (appeared in Java 6) is not even close to the OSGi service model. Much more limited, for many of the APS services the actual service returned by the ServiceLoader would have to be a factory that also sets upp the service if not already done and then provides it. ServiceLoader doesn't really support prerequisites for being able to deliver a service, and you have no control over how it is instantiated. In OSGi you can do the setup you want/need and when you have an instance ready for use by others, you can publish it. This is far more flexible. The OSGi people clearly sat down and did some thinking before comming up with a solution. 

The next problem with JPMS is that if you are adding `module-info.java` making your code into a module then all dependencies must also be JPMS modules! Someone realized the problem with this and made __Moditect__(<https://github.com/moditect/moditect>). This will convert your non JPMS dependencies into JPMS modules. This seams rather clumsy. So you can no longer have direct dependencies to maven artifacts, but have to run a job that downloads and converts them somewhere locally. At least it looks like it is possible to export all packages (`*`). Comparing to OSGi, with OSGi any jar file can just have a few extra OSGi MANIFEST.MF entries to be able to be dropped into an OSGi container. This will not affect any other use of the jar file. But when your jar file gets a _Module-info_ class into it, then it is no longer just a jar file. When I tested, as soon as a jar gets a Module-info.java it can no longer be accessed by other non module jars. There seem to be some special exception with the JDK internal APIs. Also note that no other JVM language, like Groovy, currently supporting modules themselves. There are workarounds though. 

My guess is that it is going to take a very long time before most 3rd party dependencies out there are JPMS enabled. When they are it means they are compiled by a JDK 9+ compiler and will not run on JDK 8 anymore. Then the question is, if you are not using JPMS yourself, can you use a JPMS dependency ? From what information I've been able to gather so far, the answer seem to be "_no_", even if you are running on a jdk9+ JVM. 
