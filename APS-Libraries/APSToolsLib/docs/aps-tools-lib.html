<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="generated-by" content="MarkdownDoc"/>
    <link href="docs.css" type="text/css" rel="stylesheet"/>
  </head>
  <body>
    <H1>APSToolsLib</H1>
    <p>
      This is a library of utilities including a service tracker that beats the (beep) out of the default one including exception rather than null response, timeout specification, getting a proxied service implementation that automatically uses the tracker, allocating a service, calling it, and deallocating it again. This makes it trivially easy to handle a service being restarted or redeployed. It also includes a logger utility that will lookup the standard log service and log to that if found.      
    </p>
    <p>
      This bundle provides no services. It just makes all its packages public. Every bundle included in APS makes use of APSToolsLib so it must be deployed for things to work.      
    </p>
    <p>
      Please note that this bundle has no dependencies! That is, it can be used as is without requireing any other APS bundle.      
    </p>
    <H2>APSServiceTracker</H2>
    <p>
      This does the same thing as the standard service tracker included with OSGi, but does it better with more options and flexibility. One of the differences between this tracker and the OSGi one is that this throws an <em>APSNoServiceAvailableException</em> if the service is not available. Personally I think this is easier to work with than having to check for a null result.      
    </p>
    <p>
      There are several variants of constructors, but here is an example of one of the most used ones within the APS services:      
    </p>
    <pre>
      <code>
    APSServiceTracker&lt;Service&gt; tracker = 
        new APSServiceTracker&lt;Service&gt;(context, Service.class, "20 seconds");
    tracker.start();
    
      </code>
    </pre>
    <p>
      Note that the third argument, which is a timeout can also be specified as an int in which case it is always in miliseconds. The string variant supports the a second word of "sec[onds]" and "min[utes]" which indicates the type of the first numeric value. "forever" means just that and requires just one word. Any other second words than those will be treated as milliseconds. The APSServiceTracker also has a set of constants for the timeout string value:      
    </p>
    <pre>
      <code>
    public static final String SHORT_TIMEOUT = "3 seconds";
    public static final String MEDIUM_TIMEOUT = "30 seconds";
    public static final String LARGE_TIMEOUT = "2 minutes";
    public static final String VERY_LARGE_TIMEOUT = "5 minutes";
    public static final String HUGE_LARGE_TIMEOUT = "10 minutes";
    public static final String NO_TIMEOUT = "forever";
      </code>
    </pre>
    <p>
      On bundle stop you should do:      
    </p>
    <pre>
      <code>
    tracker.stop(context);
    
      </code>
    </pre>
    <p>
      So that the tracker unregisters itself from receiving bundle/service events.      
    </p>
    <H3>Services and active service</H3>
    <p>
      The tracker tracks all instances of the service being tracked. It however have the notion of an active service. The active service is the service instance that will be returned by allocateService() (which is internally used by all other access methods also). On startup it will be the first service instance received. It will keep tracking other instances comming in, but as long as the active service does not go away it will be the one used. If the active service goes away then the the one that is at the beginning of the list of the other tracked instances will become active. If that list is empty there will be no active, which will trigger a wait for a service to become available again if allocateService() is called.      
    </p>
    <H3>Providing a logger</H3>
    <p>
      You can provide an APSLogger (see further down about APSLogger) to the tracker:      
    </p>
    <pre>
      <code>
    tracker.setLogger(apsLogger);
    
      </code>
    </pre>
    <p>
      When available the tracker will log to this.      
    </p>
    <H3>Tracker as a wrapped service</H3>
    <p>
      The tracker can be used as a wrapped service:      
    </p>
    <pre>
      <code>
    Service service = tracker.getWrappedService();
    
      </code>
    </pre>
    <p>
      This gives you a proxied <em>service</em> instance that gets the real service, calls it, releases it and return the result. This handles transparently if a service has been restarted or one instance of the service has gone away and another came available. It will wait for the specified timeout for a service to become available and if that does not happen the <em>APSNoServiceAvailableException</em> will be thrown. This is of course a runtime exception which makes the service wrapping possible without loosing the possibility to handle the case where the service is not available.      
    </p>
    <H3>Using the tracker in a similar way to the OSGi standard tracker</H3>
    <p>
      To get a service instance you do:      
    </p>
    <pre>
      <code>
    Service service = tracker.allocateService();
    
      </code>
    </pre>
    <p>
      Note that if the tracker has a timeout set then this call will wait for the service to become available if it is currently not available until an instance becomes available or the timeout time is reached. It will throw <em>APSNoServiceAvailableException</em> on failure in any case.      
    </p>
    <p>
      When done with the service do:      
    </p>
    <pre>
      <code>
    tracker.releaseService();
      </code>
    </pre>
    <H3>Accessing a service by tracker callback</H3>
    <p>
      There are a few variants to get a service instance by callback. When the callbacks are used the actual service instance will only be allocated during the callback and then released again.      
    </p>
    <H4>onServiceAvailable</H4>
    <p>
      This will result in a callback when any instance of the service becomes available. If there is more than one service instance published then there will be a callback for each.      
    </p>
    <pre>
      <code>
        tracker.onServiceAvailable(new OnServiceAvailable&lt;Service&gt;() {
            @Override
            public void onServiceAvailable(Service service, ServiceReference serviceReference) throws Exception {
                // Do something.
            }
        });
      </code>
    </pre>
    <H4>onServiceLeaving</H4>
    <p>
      This will result in a callback when any instance of the service goes away. If there is more than one service instance published the there will be a callback for each instance leaving.      
    </p>
    <pre>
      <code>
        onServiceLeaving(new OnServiceLeaving&lt;Service&gt;() {
    
            @Override
            public void onServiceLeaving(ServiceReference service, Class serviceAPI) throws Exception {
                // Handle the service leaving.
            }
        });
      </code>
    </pre>
    <p>
      Note that since the service is already gone by this time you don't get the service instance, only its reference and the class representing its API. In most cases both of these parameters are irellevant.      
    </p>
    <H4>onActiveServiceAvailable</H4>
    <p>
      This does the same thing as onServiceAvailable() but only for the active service. It uses the same <em>OnServiceAvailable</em> interface.      
    </p>
    <H4>onActiveServiceLeaving</H4>
    <p>
      This does the same thing as onServiceLeaving() but for the active service. It uses the same <em>OnServiceLeaving</em> interface.      
    </p>
    <H4>withService</H4>
    <p>
      Runs the specified callback providing it with a service to use. This will wait for a service to become available if a timeout has been provided for the tracker.      
    </p>
    <p>
      Don't use this in an activator start() method! onActiveServiceAvailable() and onActiveServiceLeaving() are safe in a start() method, this is not!      
    </p>
    <pre>
      <code>
        tracker.withService(new WithService&lt;Service&gt;() {
            @Override
            public void withService(Service service, Object... args) throws Exception {
                // do something here.
            }
        }, arg1, arg2);
      </code>
    </pre>
    <p>
      If you don't have any arguments this will also work:      
    </p>
    <pre>
      <code>
        tracker.withService(new WithService&lt;Service&gt;() {
            @Override
            public void withService(Service service) throws Exception {
                // do something here
            }
        });
      </code>
    </pre>
    <H4>withServiceIfAvailable</H4>
    <p>
      This does the same as withService(...) but without waiting for a service to become available. If the service is not available at the time of the call the callback will not be called. No exception is thrown by this!      
    </p>
    <H4>withAllAvailableServices</H4>
    <p>
      This is used exactly the same way as withService(...), but the callback will be done for each tracked service instance, not only the active.      
    </p>
    <H4>onTimeout (since 0.9.3)</H4>
    <p>
      This allows for a callback when the tracker times out waiting for a service. This callback will be called just before the <em>APSNoServiceAvailableException</em> is about to be thrown.      
    </p>
    <pre>
      <code>
    tracker.onTimeout(new OnTimeout() {
        @Override
        public void onTimeout() {
            // do something here
        }
    }); 
      </code>
    </pre>
    <H2>APSLogger</H2>
    <p>
      This provides logging functionality. The no args constructor will log to System.out by default. The OutputStream constructor will logg to the specified output stream by default.      
    </p>
    <p>
      The APSLogger can be used by just creating an instance and then start using the info(...), error(...), etc methods. But in that case it will only log to System.out or the provided OutputStream. If you however do this:      
    </p>
    <pre>
      <code>
    APSLogger logger = new APSLogger();
    logger.start(context);
    
      </code>
    </pre>
    <p>
      then the logger will try to get hold of the standard OSGi LogService and if that is available log to that. If the log service is not available it will fallback to the OutputStream.      
    </p>
    <p>
      If you call the <code>setServiceRefrence(serviceRef);</code> method on the logger then information about that service will be provied with each log.      
    </p>
    <H2>APSActivator</H2>
    <p>
      This is a BundleActivator implementation that uses annotations to register services and inject tracked services. Any bundle can use this activator by just importing the <em>se.natusoft.osgi.aps.tools</em> package.      
    </p>
    <p>
      This is actually a rather trivial class that just scans the bundle for classes and inspects all classes for annotations and act on them. Most methods are protected making it easy to subclass this class and expand on its functionality.      
    </p>
    <p>
      <strong>Please note</strong> that it does <em>class.getDeclaredFields()</em> and <em>class.getDeclaredMethods()</em>! This means that it will only see the bottom class of an inheritance hiearchy!      
    </p>
    <p>
      The following annotations are available:      
    </p>
    <p>
      <strong>@OSGiServiceProvider</strong> - This should be specified on a class that implements a service interface and should be registered as an OSGi service. <em>Please note</em> that the first declared implemented interface is used as service interface unless you specify serviceAPIs={Svc.class, ...}.      
    </p>
    <pre>
      <code>
    public @interface OSGiProperty {
        String name();
        String value();
    }
    
    public @interface OSGiServiceInstance {
    
        /** Extra properties to register the service with. */
        OSGiProperty[] properties() default {};
    
        /** The service API to register instance with. If not specified the first implemented interface will be used. */
        Class[] serviceAPIs() default {};
    }
    
    public @interface OSGiServiceProvider {
    
        /** Extra properties to register the service with. */
        OSGiProperty[] properties() default {};
    
        /** The service API to register instance with. If not specified the first implemented interface will be used. */
        Class[] serviceAPIs() default {};
    
        /** This can be used as an alternative to properties() and also supports several instances. */
        OSGiServiceInstance[] instances() default {};
    
        /**
         * This can be used as an alternative and will instantiate the specified factory class which will deliver
         * one set of Properties per instance.
         */
        Class&lt;? extends APSActivator.InstanceFactory&gt; instanceFactoryClass() default APSActivator.InstanceFactory.class;
    
        /**
         * If true this service will be stared in a separate thread. This means the bundle start
         * will continue in parallel and that any failures in startup will be logged, but will
         * not stop the bundle from being started. If this is true it wins over required service
         * dependencies of the service class. Specifying this as true allows you to do things that
         * cannot be done in a bunde activator start method, like calling a service tracked by 
         * APSServiceTracker, without causing a deadlock.
         */
        boolean threadStart() default false;
    
    }
      </code>
    </pre>
    <p>
      <strong>@OSGiService</strong> - This should be specified on a field having a type of a service interface to have a service of that type injected, and continuously tracked. Any call to the service will throw an APSNoServiceAvailableException (runtime) if no service has become available before the specified timeout. It is also possible to have APSServiceTracker as field type in which case the underlying configured tracker will be injected instead.      
    </p>
    <p>
      If <em>required=true</em> is specified and this field is in a class annotated with <em>@OSGiServiceProvider</em> then the class will not be registered as a service until the service dependency is actually available, and will also be unregistered if the tracker for the service does a timeout waiting for a service to become available. It will then be reregistered again when the dependent service becomes available again. Please note that unlike iPOJO the bundle is never stopped on dependent service unavailability, only the actual service is unregistered as an OSGi service. A bundle might have more than one service registered and when a dependency that is only required by one service goes away the other service is still available.      
    </p>
    <pre>
      <code>
    public @interface OSGiService {
    
        /** The timeout for a service to become available. Defaults to 30 seconds. */
        String timeout() default "30 seconds";
    
        /** Any additional search criteria. Should start with '(' and end with ')'. Defaults to none. */
        String additionalSearchCriteria() default "";
    
        /** If set to true the service using this service will not be registered until the service becomes available. */
        boolean required() default false;
    
    }
      </code>
    </pre>
    <p>
      <strong>@Managed</strong> - This will have an instance managed and injected. There will be a unique instance for each name specified with the default name of "default" being used if none is specified. There are 2 field types handled specially: BundleContext and APSLogger. A BundleContext field will get the bundles context injected. For an APSLogger instance the 'loggingFor' annotation property can be specified. Please note that any other type must have a default constructor to be instantiated and injected!      
    </p>
    <pre>
      <code>
    public @interface Managed {
        /**
         * The name of the instance to inject. If the same is used in multiple classes the same instance will
         * be injected.
         */
        String name() default "default";
    
        /**
         * A label indicating who is logging. If not specified the bundle name will be used. This is only
         * relevant if the injected type is APSLogger.
         */
        String loggingFor() default "";
    }
      </code>
    </pre>
    <p>
      <strong>@BundleStart</strong> - This should be used on a method and will be called on bundle start. The method should take no arguments. If you need a BundleContext just inject it with @APSInejct. The use of this annotation is only needed for things not supported by this activator. Please note that a method annotated with this annotation can be static (in which case the class it belongs to will not be instantiaded -- due to this!). You can provide this annotation on as many methods in as many classes as you want. They will all be called (in the order classes are discovered in the bundle).      
    </p>
    <pre>
      <code>
    public @interface BundleStart {
    
        /**
         * If true the start method will run in a new thread. Any failures in this case will not fail
         * the bundle startup, but will be logged.
         */
        boolean thread() default false;
    }
      </code>
    </pre>
    <p>
      <strong>@BundleStop</strong> - This should be used on a method and will be called on bundle stop. The method should take no arguments. This should probably be used if @APSBundleStart is used. Please note that a method annotated with this annotation can be static!      
    </p>
    <pre>
      <code>
    public @interface BundleStop {}
      </code>
    </pre>
    <H3>Usage as BundleActivator</H3>
    <p>
      The <em>APSActivator</em> class has 2 constructors. The default constructor without arguments are used for BundleActivator usage. In this case you just specify this class as your bundles activator, and then use the annotations described above. Thats it!      
    </p>
    <H3>Other Usage</H3>
    <p>
      Since the activator usage will manage and create instances of all annotated classes this will not always work in all situations. One example is web applications where the web container is responsible for creating servlets. If you specifiy APSActivator as an activator for a WAB bundle and then use the annotations in a servlet then APSActivator will have a managed instance of the servlet, but it will not be the same instance as the web contatiner will run.      
    </p>
    <p>
      Therefore APSActivator has another constructor that takes a vararg of instances: <code>public APSActivator(Object..</code>.<code> instances)</code>. There is also a <code>public void addManagedInstance(Object instance)</code> method. These allow you to add an already existing instance to be managed by APSActivator. In addition to the provided existing instances it will still scan the bundle for classes to manage. It will however not double manage any class for which an existing instance of has already been provided. Any annotated class for which existing instances has not been provided will be instantiated by APSActivator.      
    </p>
    <p>
      <strong>Please note</strong> that if you create an instance of APSActivator in a servlet and provide the servlet instance to it and start it (you still need to do <em>start(BundleContext)</em> and <em>stop(BundleContext)</em> when used this way!), then you need to catch the close of the servlet and do <em>stop</em> then.      
    </p>
    <p>
      There are 2 support classes in <em>APSWebTools</em>:      
    </p>
    <ul>
      <li>
        <p>
          APSVaadinOSGiApplication - This is subclassed by your Vaading application.          
        </p>
      </li>
      <li>
        <p>
          APSOSGiSupport - You create an instance of this in a servlet and let your servlet implement the <em>APSOSGiSupportCallbacks</em> interface which is then passed to the constructor of APSOSGiSupport.          
        </p>
      </li>
    </ul>
    <p>
      Both of these creates and manages an APSActivator internally and catches shutdown to take it down. They also provide other utilities like providing the BundleContext. See <em>APSWebTools</em> for more information.      
    </p>
    <H2>APSContextWrapper</H2>
    <p>
      This provides a static wrap(...) method:      
    </p>
    <pre>
      <code>
    Service providedService = APSContextWrapper.wrap(serviceProvider, Service.class);
    
      </code>
    </pre>
    <p>
      where <em>serviceProvider</em> is an instance of a class that implements <em>Service</em>. The resulting instance is a java.lang.reflect.Proxy implementation of <em>Service</em> that ensures that the <em>serviceProvider</em> ClassLoader is the context class loader during each call to all service methods that are annotated with @APSRunInBundlesContext annotation in <em>Service</em>. The wrapped instance can then be registered as the OSGi service provider.      
    </p>
    <p>
      Normally the threads context class loader is the original service callers context class loader. For a web application it would be the web containers context class loader. If a service needs its own bundles class loader during its execution then this wrapper can be used.      
    </p>
    <H2>ID generators</H2>
    <p>
      There is one interface:      
    </p>
    <pre>
      <code>
    /**
     * This is a generic interface for representing IDs. 
     */
    public interface ID extends Comparable&lt;ID&gt; {
    
        /**
         * Creates a new unique ID.
         *
         * @return A newly created ID.
         */
        public ID newID();
    
        /**
         * Tests for equality.
         *
         * @param obj The object to compare with.
         *
         * @return true if equal, false otherwise.
         */
        @Override
        public boolean equals(Object obj);
    
        /**
         * @return The hash code.
         */
        @Override
        public int hashCode();
    
    }
      </code>
    </pre>
    <p>
      that have 2 implementations:      
    </p>
    <ul>
      <li>
        <p>
          IntID - Produces int ids.          
        </p>
      </li>
      <li>
        <p>
          UUID - Produces java.util.UUID Ids.          
        </p>
      </li>
    </ul>
    <H2>Javadoc</H2>
    <p>
      The javadoc for this can be found at <a href='http://apidoc.natusoft.se/APSToolsLib/' title=''>http://apidoc.natusoft.se/APSToolsLib/</a>.      
    </p>
  </body>
</html>
