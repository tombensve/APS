package se.natusoft.osgi.aps.persistentqueue

import groovy.transform.CompileStatic
import groovy.transform.TypeChecked
import se.natusoft.docutations.Implements
import se.natusoft.osgi.aps.api.misc.queue.APSQueue
import se.natusoft.osgi.aps.exceptions.APSIOException
import se.natusoft.osgi.aps.exceptions.APSIOTimeoutException
import se.natusoft.osgi.aps.util.APSLogger
import se.natusoft.osgi.aps.activator.annotation.BundleStop

//TODO: Have to lock and wait for data on empty read, but with a timeout.

/**
 * This represents a specific named queue.
 */
@CompileStatic
@TypeChecked
class PersistentQueue implements APSQueue {

    //
    // Properties
    //

    /** Logger to log to. */
    APSLogger logger

    /** The name of the queue. */
    String queueName = null

    /** Provides the filesystem. */
    QueueStore queueStore = null

    //
    // Private Members
    //

    /** The actual modified value. This is wrapped by a synchronized 'modified' property and should not be accessed directly. */
    private boolean modif = false

    /** The reference to use for the next read from the queue. */
    private long readRef = Long.MIN_VALUE

    /** The reference to use for the next write to the queue. */
    private long writeRef = Long.MIN_VALUE

    /** For sporadic saves of indexes. This is for performance. */
    private Timer timer = new Timer()

    //
    // Inner Classes
    //

    /**
     * This is run every 5 seconds and saves the indexes if the queue has been modified since the last run.
     */
    private class SaveTask extends TimerTask {
        void run() { saveIndexes() }
    }

    //
    // Constructors
    //

    /**
     * Creates a new PersistentQueue and starts the save indexes recurrent job.
     */
    public PersistentQueue() {

        this.timer.schedule(new SaveTask(), 5000, 5000)
    }

    //
    // Methods
    //

    /**
     * This is called by APSActivator on bundle shutdown.
     */
    @BundleStop
    public void cleanup() {
        try {
            this.timer.cancel()
        }
        finally {
            saveIndexes()
        }
    }

    /**
     * Provides a synchronized getter for the 'modif' value.
     */
    private synchronized boolean getModified() {
        return this.modif
    }

    /**
     * Provides a synchronized setter for the 'modif' value.
     *
     * @param modif The new modified state to set.
     */
    private synchronized void setModified(boolean modif) {
        this.modif = modif
    }

    /**
     * Setter for the 'queueName' JavaBean property. This is implemented rather than using the autogenerated one
     * because we need to load the indexes as soon as we have both queueName and queueStore.
     *
     * @param queueName The name of the queue represented by this instance.
     *
     * @throws APSIOException on failure to load indexes.
     */
    public void setQueueName(String queueName) throws APSIOException {
        this.queueName = queueName
        loadIndexes()
    }

    /**
     * Setter for the 'queueStore' JavaBean property. This is implemented rather than using the autogenerated one
     * because we need to load the indexes as soon as we have both queueName and queueStore.
     *
     * @param queueStore The instance we used to read and write queue data.
     *
     * @throws APSIOException on failure to load indexes.
     */
    public void setQueueStore(QueueStore queueStore) throws APSIOException {
        this.queueStore = queueStore
        loadIndexes()
    }

    /**
     * Loads both the read and the write index/references.
     *
     * @throws APSIOException On failure to load the indexes.
     */
    private void loadIndexes() throws APSIOException {
        if (this.queueName != null && this.queueStore != null) {
            this.readRef = this.queueStore.getReadIndex(this.queueName)
            this.writeRef = this.queueStore.getWriteIndex(this.queueName)
        }
    }

    /**
     * Saves both the read and the write index.
     */
    private void saveIndexes() {
        if (this.modified) {
            try {
                this.queueStore.setWriteIndex(this.queueName, this.writeRef)
            } catch (Exception e) {
                this.logger.error("Failed to save write index for queue '${this.queueName}'! This means that this queue is corrupt!", e)
            }
            try {
                this.queueStore.setReadIndex(this.queueName, this.readRef)
            } catch (Exception e) {
                this.logger.error("Failed to save read index for queue '${this.queueName}'! This means that this queue is corrupt!", e)
            }

            this.modified = false
        }
    }

    /**
     * Increments the write index, handling a wraparound if we reach max.
     *
     * The idea here is that if the read index is still at the minimum index and the write index
     * at the maximum index, then the queue is full since we cannot represent another value.
     *
     * If however that is not the case then there should be free space at the bottom again to
     * reuse, so we set the index to the lowest value again, going upward until we catch up.
     *
     * @throws APSIOException If the queue is full.
     */
    private void incrementWriteRef() throws APSIOException {
        if (this.writeRef == Long.MAX_VALUE) {
            if (this.readRef == Long.MIN_VALUE) throw new APSIOException("Queue '${this.queueName}' is full!")
            this.queueStore.waitForCurrentDeletesToFinnish()
            this.writeRef = Long.MIN_VALUE
        }
        else if ((this.writeRef + 1L) == this.readRef) {
            throw new APSIOException("Queue '${this.queueName}' is full!")
        }
        else {
            ++this.writeRef
        }
    }

    /**
     * Increments the read index, handling a wraparound if we reach max.
     */
    private void incrementReadRef() {
        if (this.readRef == Long.MAX_VALUE) {
            this.readRef = Long.MIN_VALUE
        }
        else if (this.readRef == this.writeRef) {
            zeroReadWriteRefs()
            throw new APSIOException("Queue '${this.queueName}' is empty!")
        }
        else {
            ++this.readRef
        }
    }

    /**
     * This resets both the read and write indexes to the minimum value. This is done every time
     * the queue becomes empty.
     */
    private void zeroReadWriteRefs() {
        this.readRef = Long.MIN_VALUE
        this.writeRef = Long.MIN_VALUE
        this.queueStore.waitForCurrentDeletesToFinnish()
    }

    /**
     * Cleans up in this instance.
     */
    synchronized void release() {
        this.queueStore.releaseQueue(this.queueName)
    }

    /**
     * Writes an item to the queue.
     *
     * @param itemRef The item reference.
     * @param item The item to write.
     */
    private void writeItem(long itemRef, byte[] item) {
        ObjectOutputStream itemStream = null
        try {
            itemStream = new ObjectOutputStream(this.queueStore.getItemOutputStream(this.queueName, itemRef))
            itemStream.writeInt(item.length)
            itemStream.write(item)
        }
        catch (IOException ioe) {
            this.logger.error("Failed to write item!", ioe)
            throw new APSIOException("Failed to write item!", ioe)
        }
        finally {
            if (itemStream != null) itemStream.close()
        }
    }

    /**
     * Reads an item from the queue.
     *
     * @param itemRef The item reference to read.
     */
    private byte[] readItem(long itemRef) {
        ObjectInputStream itemStream = null
        try {
            itemStream = new ObjectInputStream(this.queueStore.getItemInputStream(this.queueName, itemRef))
            int length = itemStream.readInt();
            byte[] bytes = new byte[length]
            itemStream.read(bytes)

            return bytes
        }
        catch (IOException ioe) {
            this.logger.error("Failed to load item!", ioe)
            throw new APSIOException("Failed to load item!", ioe)
        }
        finally {
            if (itemStream != null) itemStream.close()
        }
    }

    /**
     * Deletes an item.
     *
     * @param itemRef The reference of the item to delete.
     */
    private void deleteItem(long itemRef) {
        this.queueStore.deleteItem(this.queueName, itemRef)
    }

    /**
     * Executes the closure hiding all exceptions.
     *
     * @param quietOp The closure to execute.
     */
    private static void silently(Closure quietOp) {
        try {
            quietOp.call()
        }
        catch (Exception ignore) {}
    }

    /**
     * Pushes a new item to the end of the list.
     *
     * @param item The item to add to the list.
     *
     * @throws APSIOException on any failure to do this operation.
     */
    @Override
    @Implements(APSQueue.class)
    synchronized void push(byte[] item) throws APSIOException {
        this.modified = true

        try {
            writeItem(this.writeRef, item)
        }
        catch (APSIOException aioe) {
            silently { deleteItem(this.writeRef) }
            throw aioe
        }

        incrementWriteRef()

        notifyAll()
    }

    /**
     * Pulls the first item in the queue, removing it from the queue.
     *
     * @param timeout A value of 0 will cause an immediate APSIOException if the queue is empty. Any
     *                other positive value will wait for that many milliseconds for something to
     *                arrive. If something does arrive during the wait then it will be returned.
     *                Otherwise an APSIOException will be thrown, with "TIMEOUT" as message.
     *
     * @return The pulled item.
     *
     * @throws APSIOException on any failure to do this operation.
     */
    @Override
    @Implements(APSQueue.class)
    synchronized byte[] pull(long timeout) throws APSIOTimeoutException {
        this.modified = true

        if (empty) {
            if (timeout == 0L) throw new APSIOException("Queue ${this.queueName} is empty!")
            //this.logger.debug("Queue '${this.queueName}' is empty, waiting for data ...")
            wait(timeout)
            if (empty) throw new APSIOTimeoutException()
        }

        byte[] itemBytes = readItem(this.readRef)

        deleteItem(this.readRef)

        incrementReadRef()

        if (empty) {
            //this.logger.debug("Zeroing refs for queue '${this.queueName}'!")
            zeroReadWriteRefs()
        }

        itemBytes
    }

    /**
     * Looks at, but does not remove the first item in the queue.
     *
     * @return The first item in the queue.
     * @throws APSIOException
     */
    @Override
    @Implements(APSQueue.class)
    synchronized byte[] peek() throws APSIOException {
        if (empty) throw new APSIOException("Queue ${this.queueName} is empty!")

        readItem(this.readRef)
    }

    /**
     * Returns the number of items in the queue.
     */
    @Override
    @Implements(APSQueue.class)
    synchronized int size() {
        if (this.writeRef < this.readRef) {
            return (this.readRef - this.writeRef) as int
        }
        return (this.writeRef - this.readRef) as int
    }

    /**
     * Returns true if this queue is empty.
     */
    @Override
    @Implements(APSQueue.class)
    synchronized boolean isEmpty() {
        return size() == 0
    }
}
